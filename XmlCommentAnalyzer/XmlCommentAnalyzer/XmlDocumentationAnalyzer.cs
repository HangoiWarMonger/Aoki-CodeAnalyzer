using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace XmlCommentAnalyzer;

/// <summary>
/// Анализатор отсутствия XML комментарев.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class XmlDocumentationAnalyzer : DiagnosticAnalyzer
{
    /// <summary>
    /// Описание правила диагностики.
    /// </summary>
    private static readonly DiagnosticDescriptor Rule = new(
        "XD0001",
        Resources.XD0001Title,
        Resources.XD0001_MessageFormat,
        "Documentation",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: Resources.XD0001_Description);

    /// <inheritdoc />
    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterSyntaxNodeAction(AnalyzeNode,
            SyntaxKind.ClassDeclaration,
            SyntaxKind.InterfaceDeclaration,
            SyntaxKind.StructDeclaration,
            SyntaxKind.EnumDeclaration,
            SyntaxKind.DelegateDeclaration,
            SyntaxKind.MethodDeclaration,
            SyntaxKind.PropertyDeclaration,
            SyntaxKind.FieldDeclaration,
            SyntaxKind.EventDeclaration,
            SyntaxKind.IndexerDeclaration,
            SyntaxKind.ConstructorDeclaration,
            SyntaxKind.DestructorDeclaration,
            SyntaxKind.OperatorDeclaration,
            SyntaxKind.ConversionOperatorDeclaration,
            SyntaxKind.EnumMemberDeclaration);
    }

    /// <inheritdoc />
    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
        ImmutableArray.Create(Rule);

    private static void AnalyzeNode(SyntaxNodeAnalysisContext context)
    {
        var node = context.Node;

        // Пропускаем приватные члены
        if (!IsPublicOrProtected(node))
            return;

        // Пропускаем автогенерированный код
        if (IsGeneratedCode(node))
            return;

        // Проверяем наличие XML документации
        if (!HasXmlDocumentation(node))
        {
            var memberName = GetMemberName(node);
            var diagnostic = Diagnostic.Create(Rule, node.GetLocation(), memberName);
            context.ReportDiagnostic(diagnostic);
        }
    }

    private static bool IsPublicOrProtected(SyntaxNode node)
    {
        var modifiers = GetModifiers(node);

        return modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword) ||
                                  m.IsKind(SyntaxKind.ProtectedKeyword));
    }

    private static bool IsGeneratedCode(SyntaxNode node)
    {
        var root = node.SyntaxTree.GetRoot();

        // Проверяем атрибуты GeneratedCode
        var compilationUnit = root as CompilationUnitSyntax;
        if (compilationUnit?.AttributeLists.Any(al =>
                al.Attributes.Any(a => a.Name.ToString().Contains("GeneratedCode"))) == true)
        {
            return true;
        }

        // Проверяем комментарии автогенерации
        var firstTrivia = root.GetLeadingTrivia().FirstOrDefault();
        if (firstTrivia.IsKind(SyntaxKind.SingleLineCommentTrivia) ||
            firstTrivia.IsKind(SyntaxKind.MultiLineCommentTrivia))
        {
            var comment = firstTrivia.ToString().ToLowerInvariant();
            return comment.Contains("auto-generated") ||
                   comment.Contains("autogenerated") ||
                   comment.Contains("<auto-generated");
        }

        return false;
    }

    private static SyntaxTokenList GetModifiers(SyntaxNode node)
    {
        return node switch
        {
            ClassDeclarationSyntax cls => cls.Modifiers,
            InterfaceDeclarationSyntax iface => iface.Modifiers,
            StructDeclarationSyntax str => str.Modifiers,
            EnumDeclarationSyntax en => en.Modifiers,
            DelegateDeclarationSyntax del => del.Modifiers,
            MethodDeclarationSyntax method => method.Modifiers,
            PropertyDeclarationSyntax prop => prop.Modifiers,
            FieldDeclarationSyntax field => field.Modifiers,
            EventDeclarationSyntax evt => evt.Modifiers,
            IndexerDeclarationSyntax indexer => indexer.Modifiers,
            ConstructorDeclarationSyntax ctor => ctor.Modifiers,
            DestructorDeclarationSyntax dtor => dtor.Modifiers,
            OperatorDeclarationSyntax op => op.Modifiers,
            ConversionOperatorDeclarationSyntax convOp => convOp.Modifiers,
            EnumMemberDeclarationSyntax => new SyntaxTokenList(),
            _ => new SyntaxTokenList()
        };
    }

    private static bool HasXmlDocumentation(SyntaxNode node)
    {
        var documentationComment = node.GetLeadingTrivia()
            .FirstOrDefault(t => t.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia) ||
                                 t.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia));

        return !documentationComment.IsKind(SyntaxKind.None);
    }

    private static string GetMemberName(SyntaxNode node)
    {
        return node switch
        {
            ClassDeclarationSyntax cls => $"class {cls.Identifier.ValueText}",
            InterfaceDeclarationSyntax iface => $"interface {iface.Identifier.ValueText}",
            StructDeclarationSyntax str => $"struct {str.Identifier.ValueText}",
            EnumDeclarationSyntax en => $"enum {en.Identifier.ValueText}",
            DelegateDeclarationSyntax del => $"delegate {del.Identifier.ValueText}",
            MethodDeclarationSyntax method => $"method {method.Identifier.ValueText}",
            PropertyDeclarationSyntax prop => $"property {prop.Identifier.ValueText}",
            FieldDeclarationSyntax field =>
                $"field {string.Join(", ", field.Declaration.Variables.Select(v => v.Identifier.ValueText))}",
            EventDeclarationSyntax evt => $"event {evt.Identifier.ValueText}",
            IndexerDeclarationSyntax => "indexer",
            ConstructorDeclarationSyntax ctor => $"constructor {ctor.Identifier.ValueText}",
            DestructorDeclarationSyntax dtor => $"destructor {dtor.Identifier.ValueText}",
            OperatorDeclarationSyntax op => $"operator {op.OperatorToken.ValueText}",
            ConversionOperatorDeclarationSyntax => "conversion operator",
            EnumMemberDeclarationSyntax enumMember => $"enum member {enumMember.Identifier.ValueText}",
            _ => "unknown member"
        };
    }
}