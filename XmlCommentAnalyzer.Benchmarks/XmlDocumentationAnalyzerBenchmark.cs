// ReSharper properties

using System.Collections.Immutable;
using System.Text;
using BenchmarkDotNet.Attributes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;

namespace XmlCommentAnalyzer.Benchmarks;

[MemoryDiagnoser]
[SimpleJob]
public class XmlDocumentationAnalyzerBenchmark
{
    private readonly List<SyntaxTree> _largeCodebase = [];
    private CSharpCompilation _largeCompilation = null!;

    private readonly DiagnosticAnalyzer _emptyAnalyzer = new EmptyAnalyzer();
    private readonly XmlDocumentationAnalyzer _originalAnalyzer = new();

    [GlobalSetup]
    public void Setup()
    {
        // Создаем различные размеры кодовых баз для тестирования
        GenerateCodebase(_largeCodebase, 100, 20);

        _largeCompilation = CSharpCompilation.Create(
            "TestAssembly",
            _largeCodebase,
            [MetadataReference.CreateFromFile(typeof(object).Assembly.Location)]
        );
    }

    // [Benchmark(Baseline = true)]
    public async Task<List<Diagnostic>> EmptyAnalyzer_LargeCodebase()
    {
        var compilationWithAnalyzers = _largeCompilation.WithAnalyzers(
            [_emptyAnalyzer],
            new AnalyzerOptions(ImmutableArray<AdditionalText>.Empty));

        var diagnostics = await compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync();
        return diagnostics.ToList();
    }

    [Benchmark]
    public async Task<List<Diagnostic>> OriginalAnalyzer_LargeCodebase()
    {
        var compilationWithAnalyzers = _largeCompilation.WithAnalyzers(
            ImmutableArray.Create<DiagnosticAnalyzer>(_originalAnalyzer),
            new AnalyzerOptions(ImmutableArray<AdditionalText>.Empty));

        var diagnostics = await compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync();
        return diagnostics.ToList();
    }

    private static void GenerateCodebase(List<SyntaxTree> codebase, int fileCount, int classesPerFile)
    {
        var random = new Random(42); // Фиксированный seed для воспроизводимости

        for (int fileIndex = 0; fileIndex < fileCount; fileIndex++)
        {
            var codeBuilder = new StringBuilder();

            // Случайно добавляем автогенерированный маркер в некоторые файлы
            if (random.NextDouble() < 0.1) // 10% файлов будут помечены как автогенерированные
            {
                codeBuilder.AppendLine("// <auto-generated />");
            }

            codeBuilder.AppendLine("using System;");
            codeBuilder.AppendLine("using System.Collections.Generic;");
            codeBuilder.AppendLine();
            codeBuilder.AppendLine($"namespace TestNamespace.File{fileIndex}");
            codeBuilder.AppendLine("{");

            for (int classIndex = 0; classIndex < classesPerFile; classIndex++)
            {
                GenerateClass(codeBuilder, $"TestClass{classIndex}", random);
                codeBuilder.AppendLine();
            }

            codeBuilder.AppendLine("}");

            var syntaxTree = CSharpSyntaxTree.ParseText(codeBuilder.ToString(), path: $"File{fileIndex}.cs");
            codebase.Add(syntaxTree);
        }
    }

    private static void GenerateClass(StringBuilder builder, string className, Random random)
    {
        var hasDocumentation = random.NextDouble() < 0.3; // 30% классов имеют документацию
        var isPublic = random.NextDouble() < 0.7; // 70% классов публичные

        if (hasDocumentation)
        {
            builder.AppendLine("    /// <summary>");
            builder.AppendLine($"    /// Test class {className}");
            builder.AppendLine("    /// </summary>");
        }

        var accessibility = isPublic ? "public" : "internal";
        builder.AppendLine($"    {accessibility} class {className}");
        builder.AppendLine("    {");

        // Генерируем поля
        int fieldCount = random.Next(2, 5);
        for (int i = 0; i < fieldCount; i++)
        {
            GenerateField(builder, $"_field{i}", random);
        }

        // Генерируем свойства
        int propertyCount = random.Next(3, 7);
        for (int i = 0; i < propertyCount; i++)
        {
            GenerateProperty(builder, $"Property{i}", random);
        }

        // Генерируем методы
        int methodCount = random.Next(2, 6);
        for (int i = 0; i < methodCount; i++)
        {
            GenerateMethod(builder, $"Method{i}", random);
        }

        builder.AppendLine("    }");
    }

    private static void GenerateField(StringBuilder builder, string fieldName, Random random)
    {
        var isPublic = random.NextDouble() < 0.2; // 20% полей публичные
        var hasDocumentation = random.NextDouble() < 0.1; // 10% полей имеют документацию

        if (hasDocumentation)
        {
            builder.AppendLine("        /// <summary>");
            builder.AppendLine($"        /// Test field {fieldName}");
            builder.AppendLine("        /// </summary>");
        }

        var accessibility = isPublic ? "public" : "private";
        builder.AppendLine($"        {accessibility} string {fieldName};");
    }

    private static void GenerateProperty(StringBuilder builder, string propertyName, Random random)
    {
        var isPublic = random.NextDouble() < 0.8; // 80% свойств публичные
        var hasDocumentation = random.NextDouble() < 0.2; // 20% свойств имеют документацию

        if (hasDocumentation)
        {
            builder.AppendLine("        /// <summary>");
            builder.AppendLine($"        /// Test property {propertyName}");
            builder.AppendLine("        /// </summary>");
        }

        var accessibility = isPublic ? "public" : "private";
        builder.AppendLine($"        {accessibility} string {propertyName} {{ get; set; }}");
    }

    private static void GenerateMethod(StringBuilder builder, string methodName, Random random)
    {
        var isPublic = random.NextDouble() < 0.6; // 60% методов публичные
        var hasDocumentation = random.NextDouble() < 0.15; // 15% методов имеют документацию

        if (hasDocumentation)
        {
            builder.AppendLine("        /// <summary>");
            builder.AppendLine($"        /// Test method {methodName}");
            builder.AppendLine("        /// </summary>");
        }

        var accessibility = isPublic ? "public" : "private";
        builder.AppendLine($"        {accessibility} void {methodName}()");
        builder.AppendLine("        {");
        builder.AppendLine("            // Method implementation");
        builder.AppendLine("        }");
    }
}